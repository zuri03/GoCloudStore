Completely refactor client to fit new architecture
    client must first send http request to metadata server for file location
    client must open tcp connection to correct data server and read/write file data from tcp connection
    Determine how to optimize connections by using the least amount of connections possible
    set up addAllowedUser, removeAllowedUser, deleteRecord requests on cli
    create more robust error/success messages for the user

set up one time command/client 
    set up switch statement in main.go similar to switch statement in cli loop

gather all steps of each command into a single function     
    this function can be called either by the cli loop or the main function for single use
    this function will have all of the steps to complete a single command to make each command more cohesive and reusable

Add rest api to record keeper
    Add dynamic urls to paths

Add local file to record keeper to keep track of records

Set up data node:
    data node will contain the file data referenced by the records in records storage
    set up a listener to listen to tcp connections on a port
    Use basic protocol to determine whether to send or accept byte data 
        - First three bytes of first message from client will determine the actions 
        - GET: client wants to retrieve data from datanode
        - SND: client wants to send data to datanode
        - DEL: client wants to delete a file on the datanode

Add users service:
    this service will be a rest api that provides persistant storage for user objects

Set up kubernetes

Create help message for the help command

Reduce docker image size

set up tls for each of the rest apis

come up with a better name for allowedUsers
    allowed users are allowed to retrieve a file despite not being the owner


Determine how allowed system works
    for now allowed users is simply a slice of usernames
    need to determine the best way to store users in this slice